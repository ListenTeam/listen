# listen链上功能实现
## 说明
* 所有额外添加的功能集中在一个模块中， 模块名称是Listen
* 除了账户金额， 所有记录均是用完即销毁，或是定期销毁，没有永久存储（个人购买道具与语音部分目前还是永久，后面会有计划删除)
* 额外添加的多资产模块， 后期使用，目前跟链下功能无关联
* 房间id是自增的u64类型
***
## 主要方法
1. 空投 
	* 代码: `fn air_drop(origin, des: T::AccountId)`
	* 参数： 
		- des: 空投的目标地址
	* 逻辑:
		- 需要listen基金会权限
		- 一个账户只能被空投一次
		- 国库给空投账户转账0.99个LT
		- 空投的账户不能被删除(不会有灰尘处理)
***
2. 创建房间
	* 代码： `fn create_room(origin, max_members: GroupMaxMembers, group_type: Vec<u8>, join_cost: BalanceOf<T>)`
	* 参数:
		- max_members： 房间人数上限(不是自定义)
		- group_type： 房间类型(自己输入字符串，自定义)
		- join_cost: 其他人加入房间需要花费的金额
	* 逻辑
		- 任何人都可以创建房间
		- 根据房间人数上限收取创建费用(账上余额不够，不给创建)， 并且费用直接转到国库
	>>> 创建费用收取： 10人群，1LT； 100人群， 10LT； 500人群， 30LT； 10000人群， 200LT； 不限制， 1000LT
***
3. 邀请别人进群
	* 代码： `fn invite(origin,  group_id: u64, listener: T::AccountId, payment_type: InvitePaymentType)`
	* 参数： 
		- group_id： 房间id
		- listener： 被邀请人
		- payment_type： 付费类型(邀请人付费或是被邀请人付费)
	* 逻辑：
		- 任何人均可以邀请别人进群， 但是不能自己邀请自己
		- 邀请进的群必须存在，并且没有被解散
		- 不能重复邀请
		- 如果是邀请人付费， 需要抵押进群费用相当的金额（账上余额不够抵押不能邀请)
	>>> 不管是邀请人付费还是被邀请人付费， 均是进群时才会真的扣除费用
***
4. 进群
	* 代码： `fn into_room(origin, group_id: u64)`
	* 参数： 
		- group_id： 房间号
	* 逻辑：
		- 签名
		- 房间存在
		- 如果自己是被邀请进群的： 邀请人付费就惩罚保留金额；被邀请人付费就从账上余额中扣除费用(余额不够不给进群)
		- 如果是被邀请： 邀请人是群主，则被邀请人身份是贵宾；如果不是群主， 则是普通听众
		- 如果自己不是被邀请进群， 需要自己支付进群费用
	>>> 进群费用明细： 5%直接转到群主账上； 5%先统计在群里， 解散后给群主； 50%直接转给国库； 40%统计到群里，作为公共费用，群解散后均分
***
5. 拒绝邀请
	* 代码：`fn reject_invite(origin, group_id: u64)`
	* 参数： 
		- group_id： 房间id
	* 逻辑：
		- 签名
		- 房间存在
		- 自己被邀请
		- 如果邀请人邀请时设置进群费用是邀请人自己出， 那么解除邀请时的抵押
***
6. 在群里购买道具
	* 代码： `fn buy_props_in_room(origin, group_id: u64, props: AllProps)`
	* 参数： 
		- group_id: 房间号
		- props： 道具类型以及分别需要买多少
	* 逻辑：
		- 签名
		- 群存在， 并且自己在群里
		- 根据道具类型与数量计算费用
		- 扣除费用(费用不够，不给操作)， 并且统计到群里， 等解散后均分
		- 购买详情个人记录有一份
	>>> 道具类型有： 文字、图片、视频(具体费用收取看白皮书)
***
7. 在群里购买语音
	* 代码： `fn buy_audio_in_room(origin, group_id: u64, audio: Audio)`
	* 参数：
		- group_id：房间id
		- audio：语音类型与数量
	* 逻辑：
		- 签名
		- 群存在， 并且自己在群里
		- 根据语音类型与数量计算费用
		- 扣除费用(费用不够，不给操作)， 并且统计到群里， 等解散后均分
		- 购买详情个人记录有一份
	>>> 语音类型有： 10s, 30s, 60s, 具体收费情况看白皮书
	
***
8. 群主修改听众权限
	* 代码: `fn change_permission(origin, group_id: u64, who: T::AccountId, permission: ListenerType)`
	* 参数： 
		- group_id： 房间id
		- who： 即将被修改权限的听众
		- permission： 权限(群主、 普通听众、 贵宾)
	* 逻辑：
		- 必须是群主才能更改其他人权限
		- 房间存在，并且被修改的那个人在群里
		- 群主不能修改自己的权限
		- 不能修改其他人权限为群主权限
***

9. 群主踢人
	* 代码： `fn kick_someone(origin, group_id: u64, who: T::AccountId)`
	* 参数： 
		- group_id： 房间id
		- who： 即将被踢出群聊的人
	* 逻辑：
		- 群存在
		- 必须是群主才能踢人
		- 被踢的人在群里
		- 群解散后， 这个被踢的人不被奖励（这里逻辑要重新审核）
		- 群主不能随意踢人： 一次仅可以踢一个人； 踢人有时间间隔要求， 具体看白皮书
***
10. 要求解散群
	* 代码： `fn ask_for_disband_room(origin, group_id: u64)`
	* 参数： 
		- 房间id： group_id
	* 逻辑：
		- 群存在， 并且要求解散的人是群里成员
		- 该群还未处于投票状态
		- 自己申请， 算自己一个赞成票
		- 解散群提案有时间间隔要求（从本群上一次解散提按结束时间算起， 具体参看白皮书）
		- 需要花费进群费用的1/10， 并且直接转到国库
		- 议案3天过期
***
11. 给解散群的提案进行投票
	* 代码： `fn vote(origin, group_id: u64, vote: VoteType)`
	* 参数： 
		- 房间id： group_id
		- vote： 投票类型(赞成或是反对)
	* 逻辑：
		- 群存在，并且投票人是群成员
		- 群必须是正在投票阶段
		- 不能投两次相同的票(可以换投反对票)
		- 如果提按结束并且通过： 把所有剩余的红包余额归还发红包的人； 把属于群主个人独享的部分奖励给群主（剩下的公共部分需要个人自己认领)
		- 如果提案结束未通过， 把投票记录删除
***
12. 自己领取奖励
	* 代码: `fn pay_out(origin)`
	* 参数无
	* 逻辑:
		- 之前有加入的房间
		- 有房间奖励处于未领取状态
		- 奖励只能领取最多20个session的， 其余算过期处理
	>>> 注意： 这个操作是领取本人所有能够领取的奖励
***
13. 在群里发红包
	* 代码： `pub fn send_redpacket_in_room(origin, group_id: u64, lucky_man_number: u32, amount: BalanceOf<T>)`
	* 参数： 
		- group_id： 房间id
		- lucky_man_number： 打算发给多少人
		- amount： 红包总金额
	* 逻辑：
		- 群存在，并且自己在群里
		- 红包金额有最小限制， 小余则不能发红包(最小金额 = 每个人领取的最小金额(系统定) * lucky_man_number)
		- 从自己账上扣除金额
		- 红包过期时间是1天
		- 顺便处理房间所有过期红包
***
14. 在群里收红包
	* 代码： `pub fn get_redpacket_in_room(origin, lucky_man: T::AccountId, group_id: u64, redpacket_id: u128, amount: BalanceOf<T>)`
	* 参数： 
		- lucky_man： 领给谁
		- group_id： 房间id
		- redpacket_id： 红包id
		- amount： 领取金额
	* 逻辑：
		- 需要listen基金会权限
		- 群存在， 自己在群里，并且这个红包存在
		- （这里有个逻辑值得商榷: 是否要限制领取红包最小金额)
		- 一个人只能领一次
		- 红包如果已经过期， 过期则把剩余的金额归还发红包的人
		- 如果领取红包的人数已经达到上限， 剩余金额归还给发红包的人
		- 顺便处理群里所有过期红包
***
